/*
    Author: Hill

    Given a 2d grid map of '1's (land) and '0's (water), count the number of islands.
    An island is surrounded by water and is formed by connecting adjacent lands horizontallyor vertically.
    You may assume all four edges of the grid are all surrounded by water.


    題意：一個只包含數字 0 和 1 的二維矩陣，找出裡面不相鄰、只包含1的區塊個數。

    思路：DFS、BFS。只要遍歷一遍，碰到一個1，就把它周圍所有相連的1都標記為非1，這樣整個遍歷過程中碰到的1的個數就是所求解。
*/


public int numIslands(char[][] grid) {
    if(grid==null || grid.length==0 || grid[0].length==0)
        return 0;
 
    int m = grid.length;
    int n = grid[0].length;
 
    int[] dx={-1, 1, 0, 0};
    int[] dy={0, 0, -1, 1};
 
    int[] root = new int[m*n];
 
    int count=0;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(grid[i][j]=='1'){
                root[i*n+j] = i*n+j;            
                count++;
            }
        }
    }
 
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(grid[i][j]=='1'){
                for(int k=0; k<4; k++){
                    int x = i+dx[k];
                    int y = j+dy[k];
 
                    if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]=='1'){
                        int cRoot = getRoot(root, i*n+j);
                        int nRoot = getRoot(root, x*n+y);
                        if(nRoot!=cRoot){
                            root[cRoot]=nRoot; //update previous node's root to be current
                            count--;
                        }
 
                    }
                }
            }
        }
    }
 
    return count;
}
 
public int getRoot(int[] arr , int i){
    while(arr[i]!=i){
        i = arr[arr[i]];
    }
 
    return i;
}